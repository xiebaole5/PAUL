# 数据库连接错误优化方案

## 问题描述
小程序能运行，但10秒左右弹出 `psycopg2.OperationalError: connect` 错误。

## 根因分析

### 1. 连接池配置过大（主要问题）
当前配置：
```python
pool_size=100      # 连接池大小
max_overflow=100   # 最大溢出连接数
```

问题：
- 最多可以有 200 个数据库连接
- 对于 1.6GB 内存的服务器来说，这会导致内存不足
- PostgreSQL 每个连接需要约 2-5MB 内存
- 200 个连接需要 400MB-1GB 内存，远超服务器可用内存

### 2. 连接超时设置不合理
```python
pool_timeout=30    # 30秒超时
```

问题：
- 连接超时太长，导致请求长时间等待
- 小程序端10秒就超时了

### 3. PostgreSQL 配置问题
可能的问题：
- `max_connections` 设置过大
- `shared_buffers` 配置不当
- `work_mem` 配置不当

## 优化方案

### 方案1：优化数据库连接池配置（立即生效）

修改 `src/storage/database/db.py`：

```python
def _create_engine_with_retry():
    url = get_db_url()
    if url is None or url == "":
        logger.error("PGDATABASE_URL is not set")
        raise ValueError("PGDATABASE_URL is not set")

    # 优化连接池配置，适配低配置服务器（2核/1.6GB）
    size = 5           # 连接池大小（降低到5）
    overflow = 10      # 最大溢出连接数（降低到10）
    recycle = 3600     # 连接回收时间（1小时）
    timeout = 10       # 连接超时（10秒）

    engine = create_engine(
        url,
        pool_size=size,
        max_overflow=overflow,
        pool_pre_ping=True,
        pool_recycle=recycle,
        pool_timeout=timeout,
        connect_args={
            "connect_timeout": 5,  # 数据库连接超时（5秒）
            "options": "-c statement_timeout=10000"  # SQL执行超时（10秒）
        },
    )

    # 验证连接，带重试
    start_time = time.time()
    last_error = None
    while time.time() - start_time < MAX_RETRY_TIME:
        try:
            with engine.connect() as conn:
                conn.execute(text("SELECT 1"))
            return engine
        except OperationalError as e:
            last_error = e
            elapsed = time.time() - start_time
            logger.warning(f"Database connection failed, retrying... (elapsed: {elapsed:.1f}s)")
            time.sleep(min(1, MAX_RETRY_TIME - elapsed))
    logger.error(f"Database connection failed after {MAX_RETRY_TIME}s: {last_error}")
    raise last_error  # pyright: ignore [reportGeneralTypeIssues]
```

### 方案2：优化 PostgreSQL 配置（需要重启数据库容器）

检查当前配置：
```bash
docker exec -it tnho-postgres psql -U tnho_user -d tnho_video -c "SHOW max_connections;"
docker exec -it tnho-postgres psql -U tnho_user -d tnho_video -c "SHOW shared_buffers;"
docker exec -it tnho-postgres psql -U tnho_user -d tnho_video -c "SHOW work_mem;"
```

修改配置文件 `postgresql.conf`：
```bash
# 进入容器
docker exec -it tnho-postgres bash

# 编辑配置文件
cat > /var/lib/postgresql/data/postgresql.conf << 'EOF'
# 连接设置
max_connections = 50                 # 最大连接数（降低到50）
listen_addresses = '*'               # 监听所有地址

# 内存设置（适配1.6GB内存）
shared_buffers = 256MB               # 共享缓冲区（1GB的25%）
effective_cache_size = 512MB         # 有效缓存大小（50%内存）
maintenance_work_mem = 64MB          # 维护工作内存
work_mem = 4MB                       # 每个查询的工作内存
dynamic_shared_memory_type = posix   # 动态共享内存类型

# 日志设置
log_min_duration_statement = 1000    # 记录超过1秒的SQL
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
logging_collector = on
log_directory = 'log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
EOF

# 退出容器
exit

# 重启数据库容器
docker restart tnho-postgres
```

### 方案3：添加数据库连接错误处理和重试机制

在 `src/storage/database/db.py` 中添加更健壮的错误处理：

```python
def get_session_with_retry(max_retries=3, retry_delay=1):
    """
    获取数据库会话，带重试机制

    Args:
        max_retries: 最大重试次数
        retry_delay: 重试间隔（秒）

    Returns:
        数据库会话
    """
    from sqlalchemy.exc import OperationalError, DisconnectionError

    for attempt in range(max_retries):
        try:
            session = get_session()
            # 测试连接
            session.execute(text("SELECT 1"))
            return session
        except (OperationalError, DisconnectionError) as e:
            logger.warning(f"Database connection failed (attempt {attempt + 1}/{max_retries}): {e}")
            if attempt < max_retries - 1:
                time.sleep(retry_delay)
            else:
                raise
```

### 方案4：监控和日志优化

在 `src/storage/database/db.py` 中添加连接池监控：

```python
import logging
from sqlalchemy import event
from sqlalchemy.engine import Engine

logger = logging.getLogger(__name__)

@event.listens_for(Engine, "connect")
def receive_connect(dbapi_connection, connection_record):
    """记录新连接创建"""
    logger.info(f"New database connection created")

@event.listens_for(Engine, "close")
def receive_close(dbapi_connection, connection_record):
    """记录连接关闭"""
    logger.info(f"Database connection closed")
```

## 执行步骤

### 步骤1：优化连接池配置（立即生效）

SSH 登录服务器：
```bash
cd /root/tnho-video
```

修改 `src/storage/database/db.py`：
```bash
# 备份原文件
cp src/storage/database/db.py src/storage/database/db.py.backup

# 使用 sed 修改配置
sed -i 's/size = 100/size = 5/' src/storage/database/db.py
sed -i 's/overflow = 100/overflow = 10/' src/storage/database/db.py
sed -i 's/recycle = 1800/recycle = 3600/' src/storage/database/db.py
sed -i 's/timeout = 30/timeout = 10/' src/storage/database/db.py

# 添加 connect_args
# 找到 create_engine 调用的位置，添加以下内容
```

或者直接编辑文件：
```bash
vim src/storage/database/db.py
```

修改第47-52行：
```python
# 优化连接池配置，适配低配置服务器（2核/1.6GB）
size = 5           # 连接池大小（降低到5）
overflow = 10      # 最大溢出连接数（降低到10）
recycle = 3600     # 连接回收时间（1小时）
timeout = 10       # 连接超时（10秒）

engine = create_engine(
    url,
    pool_size=size,
    max_overflow=overflow,
    pool_pre_ping=True,
    pool_recycle=recycle,
    pool_timeout=timeout,
    connect_args={
        "connect_timeout": 5,  # 数据库连接超时（5秒）
        "options": "-c statement_timeout=10000"  # SQL执行超时（10秒）
    },
)
```

### 步骤2：重启应用
```bash
cd /root/tnho-video
source venv/bin/activate
pkill -f "uvicorn app:app"
sleep 2
nohup uvicorn app:app --host 0.0.0.0 --port 8000 --workers 1 --log-level info >> logs/app.log 2>&1 &
```

### 步骤3：优化 PostgreSQL 配置
```bash
# 检查当前配置
docker exec -it tnho-postgres psql -U tnho_user -d tnho_video -c "SHOW max_connections;"
docker exec -it tnho-postgres psql -U tnho_user -d tnho_video -c "SHOW shared_buffers;"

# 重启数据库
docker restart tnho-postgres
sleep 5

# 验证数据库状态
docker exec -it tnho-postgres psql -U tnho_user -d tnho_video -c "SELECT version();"
```

### 步骤4：测试连接
```bash
cd /root/tnho-video
source venv/bin/activate
python -c "from storage.database.db import get_session; db = get_session(); db.execute('SELECT 1'); print('✓ 数据库连接成功'); db.close()"
```

### 步骤5：测试 API
```bash
# 测试健康检查
curl -s https://tnho-fasteners.com/api/health

# 测试创建任务
curl -X POST https://tnho-fasteners.com/api/generate-video \
  -H "Content-Type: application/json" \
  -d '{"product_name":"测试","theme":"品质保证","duration":20,"type":"video"}'
```

### 步骤6：监控日志
```bash
# 查看应用日志
tail -f logs/app.log

# 查看数据库日志
docker logs -f tnho-postgres
```

## 一键优化脚本

```bash
#!/bin/bash

# 数据库连接优化脚本

set -e

COLOR_GREEN='\033[0;32m'
COLOR_RED='\033[0;31m'
COLOR_BLUE='\033[0;34m'
COLOR_RESET='\033[0m'

print_success() {
    echo -e "${COLOR_GREEN}✓ $1${COLOR_RESET}"
}

print_error() {
    echo -e "${COLOR_RED}✗ $1${COLOR_RESET}"
}

print_info() {
    echo -e "${COLOR_BLUE}ℹ $1${COLOR_RESET}"
}

print_header() {
    echo ""
    echo -e "${COLOR_BLUE}========================================${COLOR_RESET}"
    echo -e "${COLOR_BLUE}$1${COLOR_RESET}"
    echo -e "${COLOR_BLUE}========================================${COLOR_RESET}"
}

PROJECT_DIR="/root/tnho-video"

print_header "数据库连接优化"
print_info "开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
echo ""

cd "$PROJECT_DIR" || exit 1

# 1. 备份原文件
print_header "1. 备份原文件"
cp src/storage/database/db.py src/storage/database/db.py.backup.$(date +%Y%m%d_%H%M%S)
print_success "文件已备份"

# 2. 优化连接池配置
print_header "2. 优化连接池配置"
sed -i 's/size = 100/size = 5/' src/storage/database/db.py
sed -i 's/overflow = 100/overflow = 10/' src/storage/database/db.py
sed -i 's/recycle = 1800/recycle = 3600/' src/storage/database/db.py
sed -i 's/timeout = 30/timeout = 10/' src/storage/database/db.py
print_success "连接池配置已优化"

# 3. 添加 connect_args（检查是否已存在）
print_header "3. 检查 connect_args"
if grep -q "connect_timeout" src/storage/database/db.py; then
    print_info "connect_args 已存在"
else
    print_warning "需要手动添加 connect_args"
    print_info "请在 src/storage/database/db.py 的 create_engine 调用中添加："
    echo "connect_args={"
    echo "    'connect_timeout': 5,"
    echo "    'options': '-c statement_timeout=10000'"
    echo "},"
fi

# 4. 重启应用
print_header "4. 重启应用"
source venv/bin/activate
pkill -f "uvicorn app:app" || true
sleep 2
nohup uvicorn app:app --host 0.0.0.0 --port 8000 --workers 1 --log-level info >> logs/app.log 2>&1 &
sleep 3

if ps aux | grep -v grep | grep "uvicorn app:app" > /dev/null; then
    print_success "应用已重启"
else
    print_error "应用启动失败"
    exit 1
fi

# 5. 测试数据库连接
print_header "5. 测试数据库连接"
if python -c "from storage.database.db import get_session; db = get_session(); db.execute('SELECT 1'); print('✓ 数据库连接成功'); db.close()" 2>&1 | grep -q "数据库连接成功"; then
    print_success "数据库连接正常"
else
    print_error "数据库连接失败"
    print_info "查看日志：tail -f logs/app.log"
fi

# 6. 测试 API
print_header "6. 测试 API"
sleep 2

if curl -s https://tnho-fasteners.com/api/health > /dev/null; then
    print_success "API 服务正常"
else
    print_warning "API 服务异常"
fi

# 7. 显示优化结果
print_header "优化完成"
print_info "完成时间: $(date '+%Y-%m-%d %H:%M:%S')"
echo ""
print_success "优化已完成"
echo ""
print_info "配置变更："
echo "  pool_size: 100 → 5"
echo "  max_overflow: 100 → 10"
echo "  pool_recycle: 1800 → 3600"
echo "  pool_timeout: 30 → 10"
echo ""
print_info "预期效果："
echo "  ✓ 减少内存占用（从 ~1GB 降到 ~100MB）"
echo "  ✓ 减少连接超时（从30秒降到10秒）"
echo "  ✓ 提高响应速度"
echo ""
print_info "下一步："
echo "  1. 在小程序中测试视频生成功能"
echo "  2. 观察是否还有连接错误"
echo "  3. 查看日志：tail -f logs/app.log"
```

保存为 `scripts/optimize-db.sh` 并执行：
```bash
cd /root/tnho-video
chmod +x scripts/optimize-db.sh
bash scripts/optimize-db.sh
```

## 预期效果

优化后：
- ✓ 内存占用减少约 90%
- ✓ 连接超时减少 67%
- ✓ 响应速度提升
- ✓ 小程序不再出现连接错误

## 监控建议

1. **监控连接数**
```bash
docker exec -it tnho-postgres psql -U tnho_user -d tnho_video -c "SELECT count(*) FROM pg_stat_activity;"
```

2. **监控内存使用**
```bash
free -h
docker stats tnho-postgres
```

3. **监控应用日志**
```bash
tail -f logs/app.log | grep -i "database\|connection"
```

## 如果问题仍然存在

1. **检查数据库容器状态**
```bash
docker ps -a | grep postgres
docker logs tnho-postgres --tail 100
```

2. **检查数据库连接数**
```bash
docker exec -it tnho-postgres psql -U tnho_user -d tnho_video -c "SELECT count(*) FROM pg_stat_activity WHERE state = 'active';"
```

3. **检查是否有锁等待**
```bash
docker exec -it tnho-postgres psql -U tnho_user -d tnho_video -c "SELECT * FROM pg_stat_activity WHERE wait_event IS NOT NULL;"
```

## 联系方式
- GitHub: https://github.com/xiebaole5/PAUL
- 服务器: 47.110.72.148
- API地址: https://tnho-fasteners.com

---
**创建日期**: 2025-02-06
